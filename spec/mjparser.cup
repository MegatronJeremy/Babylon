package mjparser;

import java_cup.runtime.*;
import org.apache.log4j.*;
import ast.*;

parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
        done_parsing();
        report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal error, parsing cannot be continued", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append(" on line ")
                .append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" on line ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s + " " + s.value);
	return s;
:}

terminal PROGRAM, BREAK, CLASS;
terminal ELSE, CONST, IF, NEW; 
terminal PRINT, READ; 
terminal RETURN, VOID, EXTENDS, CONTINUE, FOR, STATIC, NAMESPACE;

terminal String IDENT;
terminal Integer NUM_CONST;
terminal Character CHAR_CONST;
terminal Boolean BOOL_CONST;

terminal PLUS, MINUS, MULTIPLY, DIVIDE, MODULO, ASSIGN;
terminal EQUAL, NOT_EQUAL, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL, AND;
terminal OR, INCREMENT, DECREMENT, SEMI, COLON, COMMA, PERIOD;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE;

nonterminal Program;
nonterminal NamespaceDeclList, NamespaceDecl;
nonterminal DeclList, Decl;
nonterminal ConstDecl, ConstList, ConstType;
nonterminal VarDeclList, VarDecl, VarList, VarName;
nonterminal ClassDecl, ExtendsClause, ClassBody;
nonterminal StaticVarDeclList, StaticInitList, StaticInitializer, MethodDeclBody;
nonterminal ClassVarDeclListOpt, ClassVarDeclList;
nonterminal MethodDeclList, MethodDecl, MethodType;
nonterminal FormParsOpt, FormParsList;
nonterminal Type;
nonterminal StatementList, Statement, ElseStatement;
nonterminal StatementForDesignStmtListOpt, StatementReturnExpr, StatementPrintNumConst, StatementForDesignStmtList;
nonterminal DesignatorStatement, DesignatorOperation, DesignatorAssignList, DesignatorOpt;
nonterminal ActPars, ActParsOpt;
nonterminal Condition, CondTerm, CondFact, CondFactOpt;
nonterminal Expr, AddopTermList, Term, MulopFactorList, Factor;
nonterminal Designator, DesignatorIndOpList, DesignatorIndOp;
nonterminal Label, Assignop, Relop, Addop, Mulop;

precedence left ELSE; 

Program ::= (ProgramClass) PROGRAM IDENT NamespaceDeclList DeclList LBRACE MethodDeclList RBRACE
    ;

NamespaceDeclList ::= (NamespaceDeclListClass) NamespaceDeclList NamespaceDecl
    | (NoNamespaceDeclList)
    ; 

NamespaceDecl ::= (NamespaceDeclClass) NAMESPACE IDENT LBRACE DeclList LBRACE MethodDeclList RBRACE RBRACE
    ;

DeclList ::= (DeclListClass) DeclList Decl
    | (NoDecl)
    ;

Decl ::= (DeclConst) ConstDecl
    | (DeclVar) VarDecl
    | (DeclClass) ClassDecl
    ;

ConstDecl ::= (ConstDeclClass) CONST Type IDENT ASSIGN ConstType ConstList SEMI
    ;

ConstList ::= (ConstListClass) ConstList COMMA IDENT ASSIGN ConstType
    | (NoConstList)
    ;

ConstType ::= (ConstNum) NUM_CONST
    | (ConstChar) CHAR_CONST
    | (ConstBool) BOOL_CONST
    ;

VarDeclList ::= (VarDeclListClass) VarDeclList VarDecl
    | (NoVarDeclList)
    ;

VarDecl ::= (VarDeclClass) VarList SEMI
    | (VerDeclError) error SEMI:l
    {: parser.report_error("Badly formed variable declaration on line " + lleft, null); :}
    ;

VarList ::= (VarListClass) VarList COMMA VarName
    | (NoVarList) Type VarName
    | (VarListCommaError) error COMMA:l
    {: parser.report_error("Badly formed variable declaration on line " + lleft, null); :}
      VarName
    ;

VarName ::= (VarScalar) IDENT
    | (VarArray) IDENT LBRACKET RBRACKET
    ;

ClassDecl ::= (ClassDeclList) CLASS IDENT ExtendsClause LBRACE ClassBody RBRACE
    ;

ClassBody ::= (ClassBodyClass) StaticVarDeclList StaticInitList ClassVarDeclListOpt MethodDeclBody
    | (ClassVarDeclError) StaticVarDeclList StaticInitList error LBRACE:l 
      {: parser.report_error("Badly formed class variable declaration up to line " + lleft, null); :}  
      MethodDeclBody RBRACE
    ;

ClassVarDeclListOpt ::= (HasClassVarDeclList) ClassVarDeclList
    | (NoClassVarDeclList)
    ;

ClassVarDeclList ::= (ClassVarDeclListClass) ClassVarDeclList VarDecl
    | (ClassVarDeclSingle) VarDecl
    ;

StaticVarDeclList ::= (StaticVarDeclListClass) StaticVarDeclList STATIC VarDecl
    | (NoStaticVarDeclList)
    ;

StaticInitList ::= (StaticInitListClass) StaticInitializer StaticInitList 
    | (NoStaticInitList)
    ;

StaticInitializer ::= (StaticInitializerClass) STATIC LBRACE StatementList RBRACE
    ;

MethodDeclBody ::= (MethodDeclBodyClass) LBRACE MethodDeclList RBRACE
    | (NoMethodDeclBody)
    ;

ExtendsClause ::= (ExtendsClauseClass) EXTENDS Type
    | (NoExtendsClause)
    | (ExtendsClauseError) error:l 
    {: parser.report_error("Badly formed extends clause on line " + lleft, null); :}
    ;

MethodDeclList ::= (MethodDeclListClass) MethodDeclList MethodDecl
    | (NoMethodDeclList)
    ;

MethodDecl ::= (MethodDeclClass) MethodType IDENT LPAREN FormParsOpt RPAREN VarDeclList LBRACE StatementList RBRACE
    ;

MethodType ::= (MethodTypeClass) Type
    | (MethodVoid) VOID
    ;

FormParsOpt ::= (FormParsOptClass) FormParsList
    | (NoFormParsOpt)
    | (FormParsError) error:l
    {: parser.report_error("Badly formed formal parameter declaration on line " + lleft, null); :}
    ;

FormParsList ::= (FormParsListClass) FormParsList COMMA Type VarName
    | (FormParsListSingle) Type VarName
    | (FormParsListError) error COMMA:l
    {: parser.report_error("Badly formed formal parameter declaration on line " + lleft, null); :}
      Type VarName
    ;

Type ::= (TypeNamespace) IDENT COLON COLON IDENT
    | (TypeNoNamespace) IDENT
    ;

StatementList ::= (StatementListClass) StatementList Statement
    | (NoStatementList)
    ;

Statement ::= (StatementDesignator) DesignatorStatement SEMI
    | (StatementIfElse) IF LPAREN Condition RPAREN Statement ElseStatement
    | (StatementBreak) BREAK SEMI
    | (StatementContinue) CONTINUE SEMI
    | (StatementReturn) RETURN StatementReturnExpr SEMI
    | (StatementRead) READ LPAREN Designator RPAREN SEMI
    | (StatementPrint) PRINT LPAREN Expr StatementPrintNumConst RPAREN SEMI
    | (StatementFor) FOR LPAREN StatementForDesignStmtListOpt SEMI CondFactOpt SEMI StatementForDesignStmtListOpt RPAREN Statement
    | (StatementScoped) LBRACE StatementList RBRACE
    | (DesignatorStatementError) error SEMI:l
    {: parser.report_error("Badly formed designator statement on line " + lleft, null); :}
    ;

ElseStatement ::= (ElseStatementClass) ELSE Statement
    | (NoElseStatement)
    ;

StatementReturnExpr ::= (StatementReturnExprClass) Expr
    | (NoStatementReturnExpr)
    ;

StatementPrintNumConst ::= (StatementPrintNumConstClass) COMMA NUM_CONST
    | (NoStatementPrintNumConst)
    ;

StatementForDesignStmtListOpt ::= (StatementForDesignStmtListOptClass) StatementForDesignStmtList
    | (NoStatementForDesignStmtListOpt)
    ;

StatementForDesignStmtList ::= (StatementForDesignStmtListComma) StatementForDesignStmtList COMMA DesignatorStatement
    | (SingleStatementForDesignStmtList) DesignatorStatement
    ;

DesignatorStatement ::= (DesignatorOpStmt) Designator DesignatorOperation
    | (DesignatorAssignListStmt) LBRACKET DesignatorAssignList MULTIPLY Designator RBRACKET ASSIGN Designator
    ;

DesignatorOperation ::= (DesignatorOperationAssign) Assignop Expr
    | (DesignatorOperationCall) LPAREN ActParsOpt RPAREN
    | (DesignatorOperationIncrement) INCREMENT
    | (DesignatorOperationDecrement) DECREMENT
    ;

DesignatorAssignList ::= (DesignatorAssignListComma) DesignatorAssignList DesignatorOpt COMMA
    | (NoDesignatorAssignList)
    ;

DesignatorOpt ::= (DesignatorOptClass) Designator
    | (NoDesignatorOpt)
    ;

ActPars ::= (ActParsClass) ActPars COMMA Expr
    | (ActParsExpr) Expr
    ;

ActParsOpt ::= (ActParsOptClass) ActPars
    | (NoActParsOpt)
    ;

Condition ::= (ConditionClass) Condition OR CondTerm
    | (ConditionCondTerm) CondTerm
    | (ConditionError) error:l
    {: parser.report_error("Badly formed if condition on line " + lleft, null); :}
    ;

CondTerm ::= (CondTermClass) CondTerm AND CondFact
    | (CondTermFact) CondFact
    ;

CondFact ::= (CondFactClass) Expr
    | (CondFactRelop) Expr Relop Expr
    ;

CondFactOpt ::= (CondFactOptClass) CondFact
    | (NoCondFactOpt)
    ;

Expr ::= (ExprClass) Term AddopTermList
    | (ExprNeg) MINUS Term AddopTermList
    ;

AddopTermList ::= (AddopTermListClass) AddopTermList Addop Term
    | (NoAddopTermList)
    ;

Term ::= (TermClass) Factor MulopFactorList
    ;

MulopFactorList ::= (MulopFactorListClass) MulopFactorList Mulop Factor
    | (NoMulopFactorList)
    ;

Factor ::= (FactorDesignator) Designator
    | (FactorDesignatorActParsOpt) Designator LPAREN ActParsOpt RPAREN
    | (FactorNumConst) NUM_CONST
    | (FactorCharConst) CHAR_CONST
    | (FactorBoolConst) BOOL_CONST
    | (FactorNew) NEW Type
    | (FactorNewArray) NEW Type LBRACKET Expr RBRACKET
    | (FactorNewActParsOpt) NEW Type LPAREN ActParsOpt RPAREN
    | (FactorExpr) LPAREN Expr RPAREN
    ;

Designator ::= (DesignatorNamespace) IDENT COLON COLON IDENT DesignatorIndOpList
    | (DesignatorNoNamespace) IDENT DesignatorIndOpList
    ;

DesignatorIndOpList ::= (DesignatorIndOpListClass) DesignatorIndOpList DesignatorIndOp
    | (NoDesignatorIndOpList)
    ;

DesignatorIndOp ::= (DesignatorIndOpDot) PERIOD IDENT
    | (DesignatorIndOpBracket) LBRACKET Expr RBRACKET
    ;

Label ::= (LabelClass) IDENT
    ;

Assignop ::= (AssignopClass) ASSIGN
    ;

Relop ::= (RelopEqual) EQUAL
    | (RelopNotEqual) NOT_EQUAL
    | (RelopGreater) GREATER
    | (RelopGreaterEqual) GREATER_EQUAL
    | (RelopLess) LESS
    | (RelopLessEqual) LESS_EQUAL
    ;

Addop ::= (AddopPlus) PLUS
    | (AddopMinus) MINUS
    ;

Mulop ::= (MulopMultiply) MULTIPLY
    | (MulopDivide) DIVIDE
    | (MulopModulo) MODULO
    ;