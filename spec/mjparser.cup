package mjparser;

import java_cup.runtime.*;
import org.apache.log4j.*;
import ast.*;

parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
        done_parsing();
        report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal error, parsing cannot be continued", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append(" on line ")
                .append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" on line ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s + " " + s.value);
	return s;
:}

terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, WHILE, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, FOREACH;

terminal String IDENT;
terminal Integer NUM_CONST;
terminal Character CHAR_CONST;
terminal Boolean BOOL_CONST;

terminal PLUS, MINUS, MULTIPLY, DIVIDE, MODULO, ASSIGN;
terminal EQUAL, NOT_EQUAL, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL, AND;
terminal OR, INCREMENT, DECREMENT, SEMI, COLON, COMMA, PERIOD;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE, ARROW;

nonterminal Program;
nonterminal DeclList, Decl;
nonterminal ConstDecl, ConstList, ConstType;
nonterminal VarDeclList, VarDecl, VarList, VarType;
nonterminal ClassDecl, ExtendsClause, ClassBody, OperationDeclBody;
nonterminal ConstructorOrMethodDeclList, ConstructorOrMethodDecl;
nonterminal MethodDeclList, MethodDecl, MethodType;
nonterminal FormParsOpt, FormPars, FormList;
nonterminal Type;
nonterminal StatementList, Statement, ConstNumList;
nonterminal DesignatorStatement, DesignatorList;
nonterminal ActPars, ActParsOpt;
nonterminal Condition, CondTerm, CondFact, Expr, AddopTermList, Term, MulopFactorList, Factor;
nonterminal Designator, Label, Assignop, Relop, Addop, Mulop;

precedence left ELSE; 

Program ::= (ProgramClass) PROGRAM IDENT DeclList LBRACE MethodDeclList RBRACE
    ;

DeclList ::= (DeclListClass) DeclList Decl
    | (NoDecl);

Decl ::= (DeclConst) ConstDecl
    | (DeclVar) VarDecl
    | (DeclClass) ClassDecl
    ;

ConstDecl ::= (ConstDeclClass) CONST Type IDENT ASSIGN ConstType ConstList SEMI
    ;

ConstList ::= (ConstListClass) ConstList COMMA IDENT ASSIGN ConstType
    | (NoConstList)
    ;

ConstType ::= (ConstNum) NUM_CONST
    | (ConstChar) CHAR_CONST
    | (ConstBool) BOOL_CONST
    ;

VarDeclList ::= (VarDeclListClass) VarDeclList VarDecl
    | (NoVarDeclList)
    ;

VarDecl ::= (VarDeclClass) Type VarType VarList SEMI
    ;

VarList ::= (VarListClass) VarList COMMA VarType
    | (NoVarList)
    ;

VarType ::= (VarScalar) IDENT
    | (VarArray) IDENT LBRACKET RBRACKET
    ;

ClassDecl ::= (ClassDeclList) CLASS IDENT ExtendsClause LBRACE ClassBody RBRACE
    ;

ClassBody ::= (ClassBodyClass) VarDeclList LBRACE OperationDeclBody RBRACE
    ;

OperationDeclBody ::= (OperationDeclBodyClass) ConstructorOrMethodDeclList
    ;

ExtendsClause ::= (ExtendsClauseClass) EXTENDS
    | (NoExtendsClause)
    ;

ConstructorOrMethodDeclList ::= (ConstructorOrMethodDeclListClass) ConstructorOrMethodDeclList ConstructorOrMethodDecl
    | (NoConstructorOrMethodDeclList)
    ;

ConstructorOrMethodDecl ::= (ConstructorOptDecl) IDENT LPAREN FormParsOpt RPAREN VarDeclList LBRACE StatementList RBRACE
    | (MethodOptDecl) MethodDecl
    ;

MethodDeclList ::= (MethodDeclListClass) MethodDeclList MethodDecl
    | (NoMethodDeclList)
    ;

MethodDecl ::= (MethodDeclClass) MethodType IDENT LPAREN FormParsOpt RPAREN VarDeclList LBRACE StatementList RBRACE
    ;

MethodType ::= (MethodTypeClass) Type
    | (MethodVoid) VOID
    ;

FormParsOpt ::= (FormParsOptClass) FormPars
    | (NoFormParsOpt)
    ;

FormPars ::= (FormParsClass) Type VarType FormList
    ;

FormList ::= (FormListClass) FormList COMMA Type VarType
    | (NoFormList)
    ;

Type ::= (TypeClass) IDENT
    ;

StatementList ::= (StatementListClass) StatementList Statement
    | (NoStatementList)
    ;

Statement ::= (StatementDesignator) DesignatorStatement SEMI
    | (StatementIf) IF LPAREN Condition RPAREN Statement
    | (StatementIfElse) IF LPAREN Condition RPAREN Statement ELSE Statement
    | (StatementWhile) WHILE LPAREN Condition RPAREN Statement
    | (StatementBreak) BREAK SEMI
    | (StatementContinue) CONTINUE SEMI
    | (StatementReturn) RETURN SEMI
    | (StatementReturnExpr) RETURN Expr SEMI
    | (StatementRead) READ LPAREN Designator RPAREN SEMI
    | (StatementPrint) PRINT LPAREN Expr ConstNumList RPAREN SEMI
    | (StatementForEach) Designator PERIOD FOREACH LPAREN IDENT ARROW Statement RPAREN SEMI
    | (StatementScoped) LBRACE StatementList RBRACE
    | error SEMI:l
    {: parser.report_error("Badly formed statement on line " + lleft, null); :}
    ;

ConstNumList ::= (ConstNumListClass) ConstNumList COMMA NUM_CONST
    | (NoConstNumList)
    ;

DesignatorStatement ::= (DesignatorAssign) Designator Assignop Expr
    | (DesignatorActParsOpt) Designator LPAREN ActParsOpt RPAREN
    | (DesignatorInc) Designator INCREMENT
    | (DesignatorDec) Designator DECREMENT
    | (DesignatorAssignList) LBRACKET Designator DesignatorList RBRACKET ASSIGN Designator
    | (DesignatorAssignSkipFirst) LBRACKET DesignatorList RBRACKET ASSIGN Designator
    ;

DesignatorList ::= (DesignatorListComma) DesignatorList COMMA
    | (DesignatorListClass) DesignatorList COMMA Designator
    | (NoDesignatorList)
    ;

ActPars ::= (ActParsClass) ActPars COMMA Expr
    | (ActParsExpr) Expr
    ;

ActParsOpt ::= (ActParsOptClass) ActPars
    | (NoActParsOpt)
    ;

Condition ::= (ConditionClass) Condition OR CondTerm
    | (ConditionCondTerm) CondTerm
    ;

CondTerm ::= (CondTermClass) CondTerm AND CondFact
    | (CondTermFact) CondFact
    ;

CondFact ::= (CondFactClass) Expr
    | (CondFactRelop) Expr Relop Expr
    ;

Expr ::= (ExprClass) Term AddopTermList
    | (ExprNeg) MINUS Term AddopTermList
    ;

AddopTermList ::= (AddopTermListClass) AddopTermList Addop Term
    | (NoAddopTermList)
    ;

Term ::= (TermClass) Factor MulopFactorList
    ;

MulopFactorList ::= (MulopFactorListClass) MulopFactorList Mulop Factor
    | (NoMulopFactorList)
    ;

Factor ::= (FactorDesignator) Designator
    | (FactorDesignatorActParsOpt) Designator LPAREN ActParsOpt RPAREN
    | (FactorNumConst) NUM_CONST
    | (FactorCharConst) CHAR_CONST
    | (FactorBoolConst) BOOL_CONST
    | (FactorNew) NEW Type
    | (FactorNewArray) NEW Type LBRACKET Expr RBRACKET
    | (FactorNewActParsOpt) NEW Type LPAREN ActParsOpt RPAREN
    | (FactorExpr) LPAREN Expr RPAREN
    ;

Designator ::= (DesignatorClass) IDENT
    | (DesignatorDot) Designator PERIOD IDENT
    | (DesignatorIndex) Designator LBRACKET Expr RBRACKET
    ;

Label ::= (LabelClass) IDENT
    ;

Assignop ::= (AssignopClass) ASSIGN
    ;

Relop ::= (RelopEqual) EQUAL
    | (RelopNotEqual) NOT_EQUAL
    | (RelopGreater) GREATER
    | (RelopGreaterEqual) GREATER_EQUAL
    | (RelopLess) LESS
    | (RelopLessEqual) LESS_EQUAL
    ;

Addop ::= (AddopPlus) PLUS
    | (AddopMinus) MINUS
    ;

Mulop ::= (MulopMultiply) MULTIPLY
    | (MulopDivide) DIVIDE
    | (MulopModulo) MODULO
    ;